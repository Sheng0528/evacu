import osmnx as ox
import networkx as nx
import matplotlib.pyplot as plt
from matplotlib.widgets import Button
import numpy as np
from shapely.geometry import Point, LineString
from collections import defaultdict

class RoadNetworkSelector:
    def __init__(self, location=None, dist=1000, location_name=""):
        # Store location name
        self.location_name = location_name if location_name else "Selected Area"

        # Get map data using coordinates (more reliable than place names)
        if location:
            self.G = ox.graph_from_point(location, dist=dist, network_type='drive')
        else:
            # Default to Shanghai center coordinates
            self.G = ox.graph_from_point((31.2304, 121.4737), dist=2000, network_type='drive')
            if not location_name:
                self.location_name = "Shanghai"

        # Project the graph
        self.G = ox.project_graph(self.G)

        # Get nodes and edges
        self.nodes, self.edges = ox.graph_to_gdfs(self.G)

        # Save original graph
        self.original_G = self.G.copy()

        # Create an empty graph to store selected nodes and edges - use MultiDiGraph instead of DiGraph
        self.selected_G = nx.MultiDiGraph()

        # Add graph attributes from original graph
        for key, value in self.original_G.graph.items():
            self.selected_G.graph[key] = value

        # Store selected node and edge IDs
        self.selected_nodes = set()
        self.selected_edges = set()
        self.arterial_edges = set()  # New set to store arterial road edges

        # Interaction state
        self.mode = 'nodes'  # 'nodes', 'edges', or 'arterial'
        self.selecting = False
        self.temp_edge = []  # Temporarily store nodes for edge selection

        # Create plot window
        self.fig, self.ax = plt.subplots(figsize=(12, 10))
        plt.subplots_adjust(bottom=0.2, top=0.9)  # Make space for buttons and title

        # Add buttons
        self.add_buttons()

        # Initial map draw
        self.draw_map()
        self.connect_events()

        plt.tight_layout()
        plt.show()

    def add_buttons(self):
        # Add toggle mode button
        ax_toggle = plt.axes([0.15, 0.05, 0.2, 0.075])
        self.btn_toggle = Button(ax_toggle, 'Switch to Road Selection')
        self.btn_toggle.on_clicked(self.toggle_mode)

        # Add arterial road toggle button (new)
        ax_arterial = plt.axes([0.15, 0.13, 0.2, 0.075])
        self.btn_arterial = Button(ax_arterial, 'Switch to Arterial Selection')
        self.btn_arterial.on_clicked(self.toggle_arterial)

        # Add done button
        ax_done = plt.axes([0.4, 0.05, 0.2, 0.075])
        self.btn_done = Button(ax_done, 'Complete Selection')
        self.btn_done.on_clicked(self.finalize_selection)

        # Add reset button
        ax_reset = plt.axes([0.65, 0.05, 0.2, 0.075])
        self.btn_reset = Button(ax_reset, 'Reset')
        self.btn_reset.on_clicked(self.reset_selection)

    def draw_map(self):
        self.ax.clear()

        # Draw original map edges
        edges = self.edges.copy()
        edge_colors = ['grey'] * len(edges)
        edge_widths = [1] * len(edges)

        # Highlight selected edges and arterial roads
        for i, (u, v, k) in enumerate(edges.index):
            if (u, v, k) in self.selected_edges:
                if (u, v, k) in self.arterial_edges:
                    edge_colors[i] = 'black'  # Arterial roads are black
                    edge_widths[i] = 4        # And thicker
                else:
                    edge_colors[i] = 'blue'   # Regular selected roads are blue
                    edge_widths[i] = 3

        # Draw edges
        edges.plot(ax=self.ax, color=edge_colors, linewidth=edge_widths, alpha=0.7)

        # Draw original nodes
        node_colors = ['lightgrey'] * len(self.nodes)
        node_sizes = [30] * len(self.nodes)

        # Highlight selected nodes
        for i, node_id in enumerate(self.nodes.index):
            if node_id in self.selected_nodes:
                node_colors[i] = 'red'
                node_sizes[i] = 100

        # Draw nodes
        self.nodes.plot(ax=self.ax, color=node_colors, markersize=node_sizes, alpha=0.8)

        # Set location name as the main title
        plt.suptitle(self.location_name, fontsize=16, y=0.98)

        if self.mode == 'nodes':
            subtitle = 'Selection Mode: Nodes - Click on intersections'
            self.btn_toggle.label.set_text('Switch to Road Selection')
            self.btn_arterial.label.set_text('Switch to Arterial Selection')
        elif self.mode == 'edges':
            subtitle = 'Selection Mode: Roads - Click two nodes to select shortest path between them'
            self.btn_toggle.label.set_text('Switch to Node Selection')
            self.btn_arterial.label.set_text('Switch to Arterial Selection')
        else:  # arterial mode
            subtitle = 'Selection Mode: Arterial Roads - Click on roads to mark/unmark as arterial'
            self.btn_toggle.label.set_text('Switch to Node Selection')
            self.btn_arterial.label.set_text('Switch to Road Selection')

        plt.title(subtitle, fontsize=12)

        self.ax.set_xlabel('Longitude')
        self.ax.set_ylabel('Latitude')
        self.fig.canvas.draw_idle()

    def connect_events(self):
        self.cid_click = self.fig.canvas.mpl_connect('button_press_event', self.on_click)

    def toggle_mode(self, event):
        if self.mode == 'nodes':
            self.mode = 'edges'
            self.btn_toggle.label.set_text('Switch to Node Selection')
        else:
            self.mode = 'nodes'
            self.btn_toggle.label.set_text('Switch to Road Selection')
        self.temp_edge = []  # Reset temporary edge
        self.draw_map()

    def toggle_arterial(self, event):
        if self.mode == 'arterial':
            self.mode = 'edges'
            self.btn_arterial.label.set_text('Switch to Arterial Selection')
        else:
            self.mode = 'arterial'
            self.btn_arterial.label.set_text('Switch to Road Selection')
        self.temp_edge = []  # Reset temporary edge
        self.draw_map()

    def on_click(self, event):
        if event.inaxes != self.ax:
            return

        if self.mode == 'nodes':
            self.select_node(event)
        elif self.mode == 'edges':
            self.select_edge(event)
        else:  # arterial mode
            self.select_arterial(event)

    def select_node(self, event):
        # Get click position
        x, y = event.xdata, event.ydata
        click_point = Point(x, y)

        # Find nearest node
        min_dist = float('inf')
        nearest_node = None

        for node_id, node_data in self.nodes.iterrows():
            node_geom = node_data.geometry
            dist = node_geom.distance(click_point)
            if dist < min_dist:
                min_dist = dist
                nearest_node = node_id

        # If node found and close enough (30 units is an empirical value, adjust as needed)
        if nearest_node is not None and min_dist < 100:
            if nearest_node in self.selected_nodes:
                # Remove the node (do NOT remove any edges)
                self.selected_nodes.remove(nearest_node)
                print(f"取消选择节点: {nearest_node}，但保留相关边")
            else:
                self.selected_nodes.add(nearest_node)
                print(f"选择节点: {nearest_node}")

            # Redraw the map
            self.draw_map()

    def select_edge(self, event):
        # Get click position
        x, y = event.xdata, event.ydata
        click_point = Point(x, y)

        # Find nearest node
        min_dist = float('inf')
        nearest_node = None

        for node_id, node_data in self.nodes.iterrows():
            node_geom = node_data.geometry
            dist = node_geom.distance(click_point)
            if dist < min_dist:
                min_dist = dist
                nearest_node = node_id

        # If node found and close enough
        if nearest_node is not None and min_dist < 100:
            self.temp_edge.append(nearest_node)
            print(f"选择节点: {nearest_node}")

            # If two nodes selected, find and add shortest path between them
            if len(self.temp_edge) == 2:
                start_node, end_node = self.temp_edge

                # Find shortest path
                path = self.find_shortest_path(start_node, end_node)

                if path:
                    # Add all nodes in the path
                    for node in path:
                        self.selected_nodes.add(node)

                    # Add all edges along the path
                    for i in range(len(path) - 1):
                        u, v = path[i], path[i + 1]
                        if self.original_G.has_edge(u, v):
                            # There might be multiple edges between the same nodes
                            # Get all edges between u and v
                            for k in self.original_G.get_edge_data(u, v).keys():
                                self.selected_edges.add((u, v, k))
                                print(f"添加边: ({u}, {v}, {k})")

                    print(f"已添加从 {start_node} 到 {end_node} 的最短路径，共包含 {len(path)} 个节点")

                # Reset temporary edge
                self.temp_edge = []

            # Redraw the map
            self.draw_map()

    def select_arterial(self, event):
        # Get click position
        x, y = event.xdata, event.ydata
        click_point = Point(x, y)

        # Find nearest edge
        min_dist = float('inf')
        nearest_edge = None

        for edge_idx, edge_data in self.edges.iterrows():
            edge_geom = edge_data.geometry
            dist = edge_geom.distance(click_point)
            if dist < min_dist:
                min_dist = dist
                nearest_edge = edge_idx

        # If edge found and close enough (30 units is an empirical value, adjust as needed)
        if nearest_edge is not None and min_dist < 30:
            u, v, k = nearest_edge
            
            # Check if this edge is already selected
            if (u, v, k) in self.selected_edges:
                # Toggle arterial road status
                if (u, v, k) in self.arterial_edges:
                    self.arterial_edges.remove((u, v, k))
                    print(f"取消主干道标记: ({u}, {v}, {k})")
                else:
                    self.arterial_edges.add((u, v, k))
                    print(f"标记为主干道: ({u}, {v}, {k})")
            else:
                # Add edge to selected edges first, then mark as arterial
                self.selected_edges.add((u, v, k))
                self.arterial_edges.add((u, v, k))
                
                # Also add the nodes to selected nodes
                self.selected_nodes.add(u)
                self.selected_nodes.add(v)
                
                print(f"添加并标记为主干道: ({u}, {v}, {k})")

            # Redraw the map
            self.draw_map()

    def find_shortest_path(self, start_node, end_node):
        """Find the shortest path between two nodes based on edge length"""
        try:
            # Try to find path in original graph
            path = nx.shortest_path(self.original_G, start_node, end_node, weight='length')
            return path
        except nx.NetworkXNoPath:
            print(f"节点 {start_node} 与 {end_node} 之间没有找到路径")
            return None

    def finalize_selection(self, event):
        # Check if there are any nodes or edges selected
        if len(self.selected_nodes) == 0:
            print("没有选择任何节点")
            return

        if len(self.selected_edges) == 0:
            print("没有选择任何有效边")
            return

        # Create selected subgraph - use MultiDiGraph instead of DiGraph
        self.selected_G = nx.MultiDiGraph()

        # Copy graph attributes from original graph
        for key, value in self.original_G.graph.items():
            self.selected_G.graph[key] = value

        # Add selected nodes (only those in self.selected_nodes)
        for node_id in self.selected_nodes:
            if node_id in self.original_G.nodes:
                node_data = self.original_G.nodes[node_id]
                self.selected_G.add_node(node_id, **node_data)

        # Add selected edges (even if they connect到未选中的节点)
        for u, v, k in self.selected_edges:
            if self.original_G.has_edge(u, v, key=k):
                # 保证边的两个端点都在selected_G里
                for node in [u, v]:
                    if node not in self.selected_G.nodes and node in self.original_G.nodes:
                        node_data = self.original_G.nodes[node]
                        self.selected_G.add_node(node, **node_data)
                edge_data = self.original_G.get_edge_data(u, v, key=k)
                # Add arterial flag to edge attributes
                edge_data['arterial'] = (u, v, k) in self.arterial_edges
                self.selected_G.add_edge(u, v, key=k, **edge_data)

        # Create new window to display selected network
        self.display_selected_network()

    def display_selected_network(self):
        try:
            # Create new window
            fig, ax = plt.subplots(figsize=(10, 8))

            # 获取所有边和节点
            nodes, edges = ox.graph_to_gdfs(self.selected_G)
            
            if len(edges) > 0:
                # 步骤1: 首先画原始边，区分普通道路和干路
                # Create a copy of the edges dataframe
                edge_colors = []
                edge_widths = []
                
                # Set color and width based on arterial attribute
                for _, edge_data in edges.iterrows():
                    if edge_data.get('arterial', False):
                        edge_colors.append('black')
                        edge_widths.append(4)
                    else:
                        edge_colors.append('blue')
                        edge_widths.append(2)
                
                # Plot edges with their respective colors and widths
                edges.plot(ax=ax, color=edge_colors, linewidth=edge_widths)
                
                # 步骤2: 识别需要合并的路径
                # 创建一个图来表示最终路径的拓扑结构
                path_graph = nx.Graph()
                
                # 添加所有节点
                for node_id in self.selected_G.nodes():
                    # 只添加用户明确选择的节点和度不为2的节点
                    if node_id in self.selected_nodes or self.selected_G.degree(node_id) != 2:
                        path_graph.add_node(node_id)
                
                # 找出所有需要合并的路径
                paths = []
                visited_edges = set()
                
                # 处理所有边
                for u, v, k in list(self.selected_G.edges(keys=True)):
                    if (u, v, k) in visited_edges or (v, u, k) in visited_edges:
                        continue
                    
                    # 设置起点和当前路径
                    start_node = u
                    current_node = v
                    current_path = [u, v]
                    path_edges = [(u, v, k)]
                    visited_edges.add((u, v, k))
                    
                    # 如果终点是一个关键节点(度不为2或用户选择的节点)，结束路径
                    while (current_node not in self.selected_nodes and 
                           self.selected_G.degree(current_node) == 2):
                        # 找到当前节点的下一个邻居(不是我们来时的节点)
                        next_nodes = list(self.selected_G.neighbors(current_node))
                        next_node = next_nodes[0] if next_nodes[0] != current_path[-2] else next_nodes[1]
                        
                        # 获取这条边的键
                        next_edge_keys = list(self.selected_G.get_edge_data(current_node, next_node).keys())
                        if not next_edge_keys:  # 如果没有边，尝试反向边
                            next_edge_keys = list(self.selected_G.get_edge_data(next_node, current_node).keys())
                            if not next_edge_keys:
                                break  # 没有边，结束路径
                        
                        # 添加到路径
                        current_path.append(next_node)
                        path_edges.append((current_node, next_node, next_edge_keys[0]))
                        visited_edges.add((current_node, next_node, next_edge_keys[0]))
                        
                        # 更新当前节点
                        current_node = next_node
                        
                        # 如果下一个节点是关键节点或起点，结束路径
                        if (next_node in self.selected_nodes or 
                            self.selected_G.degree(next_node) != 2 or
                            next_node == start_node):
                            break
                    
                    # 存储找到的路径
                    if len(current_path) > 2:
                        paths.append((current_path, path_edges))
                    elif len(current_path) == 2:
                        # 直接连接两个关键节点的单边
                        path_graph.add_edge(current_path[0], current_path[1])
                
                # 步骤3: 计算每条合并路径的总权值并显示
                for path_nodes, path_edges in paths:
                    # 计算总长度
                    total_length = 0
                    for u, v, k in path_edges:
                        edge_data = self.selected_G.get_edge_data(u, v, key=k)
                        length = edge_data.get('length', 0)
                        total_length += length
                    
                    # 添加到路径图
                    path_graph.add_edge(path_nodes[0], path_nodes[-1])
                    
                    # 计算路径的中心点用于显示标签
                    mid_node_idx = len(path_nodes) // 2
                    if len(path_nodes) % 2 == 0:  # 偶数个节点
                        n1_idx = mid_node_idx - 1
                        n2_idx = mid_node_idx
                        n1_coords = (nodes.loc[path_nodes[n1_idx]].geometry.x, nodes.loc[path_nodes[n1_idx]].geometry.y)
                        n2_coords = (nodes.loc[path_nodes[n2_idx]].geometry.x, nodes.loc[path_nodes[n2_idx]].geometry.y)
                        mid_x = (n1_coords[0] + n2_coords[0]) / 2
                        mid_y = (n1_coords[1] + n2_coords[1]) / 2
                    else:  # 奇数个节点
                        mid_node = path_nodes[mid_node_idx]
                        mid_x = nodes.loc[mid_node].geometry.x
                        mid_y = nodes.loc[mid_node].geometry.y
                    
                    # 在路径中心显示总长度
                    ax.text(mid_x, mid_y, f"{total_length:.1f}m", 
                            fontsize=9, color='green', backgroundcolor='white',
                            ha='center', va='center', weight='bold')
                
                # 步骤4: 处理单边（直接连接两个关键节点的边）
                for u, v in path_graph.edges():
                    if not path_graph.has_edge(u, v):
                        continue
                        
                    # 检查是否有直接边
                    edge_lengths = []
                    if self.selected_G.has_edge(u, v):
                        for k in self.selected_G.get_edge_data(u, v).keys():
                            edge_data = self.selected_G.get_edge_data(u, v, k)
                            length = edge_data.get('length', 0)
                            edge_lengths.append(length)
                    
                    if self.selected_G.has_edge(v, u):
                        for k in self.selected_G.get_edge_data(v, u).keys():
                            edge_data = self.selected_G.get_edge_data(v, u, k)
                            length = edge_data.get('length', 0)
                            edge_lengths.append(length)
                    
                    if edge_lengths:
                        total_length = sum(edge_lengths)
                        
                        # 计算边的中点
                        u_coords = (nodes.loc[u].geometry.x, nodes.loc[u].geometry.y)
                        v_coords = (nodes.loc[v].geometry.x, nodes.loc[v].geometry.y)
                        mid_x = (u_coords[0] + v_coords[0]) / 2
                        mid_y = (u_coords[1] + v_coords[1]) / 2
                        
                        # 在中点显示总长度
                        ax.text(mid_x, mid_y, f"{total_length:.1f}m", 
                                fontsize=9, color='green', backgroundcolor='white',
                                ha='center', va='center', weight='bold')
            
            # 只画self.selected_nodes中的节点
            if len(self.selected_nodes) > 0:
                # 获取self.selected_nodes对应的gdf（用原nodes表过滤）
                plot_nodes = self.nodes.loc[list(self.selected_nodes)]
                plot_nodes.plot(ax=ax, color='red', markersize=50)

            # Add legend for road types
            from matplotlib.lines import Line2D
            legend_elements = [
                Line2D([0], [0], color='blue', linewidth=2, label='Regular Road'),
                Line2D([0], [0], color='black', linewidth=4, label='Arterial Road')
            ]
            ax.legend(handles=legend_elements, loc='upper right')

            ax.set_title(f'Selected Road Network - {self.location_name}')
            plt.tight_layout()
            plt.show()
        except ValueError as e:
            print(f"获取节点和边时出现错误，可能是图为空: {e}")
            print(f"图中节点数: {len(self.selected_G.nodes)}")
            print(f"图中边数: {self.selected_G.number_of_edges()}")
        except Exception as e:
            print(f"显示所选网络时出错: {e}")
            import traceback
            traceback.print_exc()

    def reset_selection(self, event):
        self.selected_nodes = set()
        self.selected_edges = set()
        self.arterial_edges = set()  # Reset arterial edges too
        self.temp_edge = []
        self.draw_map()
        print("已重置所有选择")

if __name__ == "__main__":
    # Nishinomiya, Hyogo, Japan
    selector = RoadNetworkSelector(
        location=(34.7378, 135.3423),
        dist=1000,
        location_name="Nishinomiya, Hyogo"
    )
