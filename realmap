import osmnx as ox
import networkx as nx
import matplotlib.pyplot as plt
from matplotlib.widgets import Button
import numpy as np
from shapely.geometry import Point, LineString, Polygon, MultiPolygon
from shapely.ops import polygonize, unary_union, linemerge, snap
from collections import defaultdict
import itertools

class RoadNetworkSelector:
    def __init__(self, location=None, dist=1000, location_name=""):
        self.location_name = location_name if location_name else "Selected Area"

        if location:
            self.G = ox.graph_from_point(location, dist=dist, network_type='drive')
        else:
            self.G = ox.graph_from_point((31.2304, 121.4737), dist=2000, network_type='drive')
            if not location_name:
                self.location_name = "Shanghai"

        self.G = ox.project_graph(self.G)
        self.nodes, self.edges = ox.graph_to_gdfs(self.G)
        self.original_G = self.G.copy()

        self.selected_G = nx.MultiDiGraph()
        for key, value in self.original_G.graph.items():
            self.selected_G.graph[key] = value

        self.selected_nodes = set()
        self.selected_edges = set()
        self.arterial_edges = set()
        self.gathering_points = set()  # New: Set to store gathering points P

        self.mode = 'nodes'
        self.selecting = False
        self.temp_edge = []

        self.fig, self.ax = plt.subplots(figsize=(12, 10))
        plt.subplots_adjust(bottom=0.2, top=0.9)
        self.add_buttons()
        self.draw_map()
        self.connect_events()
        plt.tight_layout()
        plt.show()

    def add_buttons(self):
        ax_toggle = plt.axes([0.1, 0.05, 0.15, 0.075])
        self.btn_toggle = Button(ax_toggle, 'Switch to Road Selection')
        self.btn_toggle.on_clicked(self.toggle_mode)

        ax_arterial = plt.axes([0.1, 0.13, 0.15, 0.075])
        self.btn_arterial = Button(ax_arterial, 'Switch to Arterial Selection')
        self.btn_arterial.on_clicked(self.toggle_arterial)

        # New: Add button for gathering points selection mode
        ax_gathering = plt.axes([0.3, 0.05, 0.15, 0.075])
        self.btn_gathering = Button(ax_gathering, 'Switch to Gathering Points')
        self.btn_gathering.on_clicked(self.toggle_gathering)

        ax_done = plt.axes([0.5, 0.05, 0.15, 0.075])
        self.btn_done = Button(ax_done, 'Complete Selection')
        self.btn_done.on_clicked(self.finalize_selection)

        ax_reset = plt.axes([0.7, 0.05, 0.15, 0.075])
        self.btn_reset = Button(ax_reset, 'Reset')
        self.btn_reset.on_clicked(self.reset_selection)

    def draw_map(self):
        self.ax.clear()
        edges = self.edges.copy()
        edge_colors = ['grey'] * len(edges)
        edge_widths = [1] * len(edges)

        for i, (u, v, k) in enumerate(edges.index):
            if (u, v, k) in self.selected_edges:
                if (u, v, k) in self.arterial_edges:
                    edge_colors[i] = 'black'
                    edge_widths[i] = 4
                else:
                    edge_colors[i] = 'blue'
                    edge_widths[i] = 3

        edges.plot(ax=self.ax, color=edge_colors, linewidth=edge_widths, alpha=0.7)

        node_colors = ['lightgrey'] * len(self.nodes)
        node_sizes = [30] * len(self.nodes)

        for i, node_id in enumerate(self.nodes.index):
            if node_id in self.gathering_points:  # New: Check if node is a gathering point
                node_colors[i] = 'green'
                node_sizes[i] = 120
            elif node_id in self.selected_nodes:
                node_colors[i] = 'red'
                node_sizes[i] = 100

        self.nodes.plot(ax=self.ax, color=node_colors, markersize=node_sizes, alpha=0.8)
        plt.suptitle(self.location_name, fontsize=16, y=0.98)

        if self.mode == 'nodes':
            subtitle = 'Selection Mode: Nodes - Click on intersections'
            self.btn_toggle.label.set_text('Switch to Road Selection')
            self.btn_arterial.label.set_text('Switch to Arterial Selection')
            self.btn_gathering.label.set_text('Switch to Gathering Points')
        elif self.mode == 'edges':
            subtitle = 'Selection Mode: Roads - Click two nodes to select shortest path between them'
            self.btn_toggle.label.set_text('Switch to Node Selection')
            self.btn_arterial.label.set_text('Switch to Arterial Selection')
            self.btn_gathering.label.set_text('Switch to Gathering Points')
        elif self.mode == 'arterial':
            subtitle = 'Selection Mode: Arterial Roads - Click on roads to mark/unmark as arterial'
            self.btn_toggle.label.set_text('Switch to Node Selection')
            self.btn_arterial.label.set_text('Switch to Road Selection')
            self.btn_gathering.label.set_text('Switch to Gathering Points')
        else:  # New: 'gathering' mode
            subtitle = 'Selection Mode: Gathering Points - Click on nodes to mark/unmark as gathering point P'
            self.btn_toggle.label.set_text('Switch to Node Selection')
            self.btn_arterial.label.set_text('Switch to Arterial Selection')
            self.btn_gathering.label.set_text('Switch to Road Selection')

        plt.title(subtitle, fontsize=12)
        self.ax.set_xlabel('Longitude')
        self.ax.set_ylabel('Latitude')
        self.fig.canvas.draw_idle()

    def connect_events(self):
        self.cid_click = self.fig.canvas.mpl_connect('button_press_event', self.on_click)

    def toggle_mode(self, event):
        if self.mode == 'nodes':
            self.mode = 'edges'
            self.btn_toggle.label.set_text('Switch to Node Selection')
        else:
            self.mode = 'nodes'
            self.btn_toggle.label.set_text('Switch to Road Selection')
        self.temp_edge = []
        self.draw_map()

    def toggle_arterial(self, event):
        if self.mode == 'arterial':
            self.mode = 'edges'
            self.btn_arterial.label.set_text('Switch to Arterial Selection')
        else:
            self.mode = 'arterial'
            self.btn_arterial.label.set_text('Switch to Road Selection')
        self.temp_edge = []
        self.draw_map()

    # New: Add method for toggling gathering point selection mode
    def toggle_gathering(self, event):
        if self.mode == 'gathering':
            self.mode = 'edges'
            self.btn_gathering.label.set_text('Switch to Gathering Points')
        else:
            self.mode = 'gathering'
            self.btn_gathering.label.set_text('Switch to Road Selection')
        self.temp_edge = []
        self.draw_map()

    def on_click(self, event):
        if event.inaxes != self.ax:
            return
        if self.mode == 'nodes':
            self.select_node(event)
        elif self.mode == 'edges':
            self.select_edge(event)
        elif self.mode == 'arterial':
            self.select_arterial(event)
        else:  # New: Handle gathering point selection
            self.select_gathering_point(event)

    def select_node(self, event):
        x, y = event.xdata, event.ydata
        click_point = Point(x, y)
        min_dist = float('inf')
        nearest_node = None
        for node_id, node_data in self.nodes.iterrows():
            node_geom = node_data.geometry
            dist = node_geom.distance(click_point)
            if dist < min_dist:
                min_dist = dist
                nearest_node = node_id
        if nearest_node is not None and min_dist < 100:
            if nearest_node in self.selected_nodes:
                self.selected_nodes.remove(nearest_node)
                print(f"取消选择节点: {nearest_node}，但保留相关边")
            else:
                self.selected_nodes.add(nearest_node)
                print(f"选择节点: {nearest_node}")
            self.draw_map()

    # New: Add method for selecting gathering points
    def select_gathering_point(self, event):
        x, y = event.xdata, event.ydata
        click_point = Point(x, y)
        min_dist = float('inf')
        nearest_node = None
        for node_id, node_data in self.nodes.iterrows():
            node_geom = node_data.geometry
            dist = node_geom.distance(click_point)
            if dist < min_dist:
                min_dist = dist
                nearest_node = node_id
        if nearest_node is not None and min_dist < 100:
            if nearest_node in self.gathering_points:
                self.gathering_points.remove(nearest_node)
                print(f"取消选择集合点P: {nearest_node}")
            else:
                self.gathering_points.add(nearest_node)
                # Also ensure the node is selected as a normal node
                if nearest_node not in self.selected_nodes:
                    self.selected_nodes.add(nearest_node)
                print(f"选择集合点P: {nearest_node}")
            self.draw_map()

    def select_edge(self, event):
        x, y = event.xdata, event.ydata
        click_point = Point(x, y)

        # 先判断最近节点
        min_node_dist = float('inf')
        nearest_node = None
        for node_id, node_data in self.nodes.iterrows():
            node_geom = node_data.geometry
            dist = node_geom.distance(click_point)
            if dist < min_node_dist:
                min_node_dist = dist
                nearest_node = node_id

        # 只有距离节点比较远时，才考虑查边
        node_threshold = 40  # 可以根据实际交互调整，建议30~50

        if min_node_dist >= node_threshold:
            # 查找最近边
            min_edge_dist = float('inf')
            nearest_edge = None
            for edge_idx in self.selected_edges:
                if edge_idx in self.edges.index:
                    edge_geom = self.edges.loc[edge_idx].geometry
                    dist = edge_geom.distance(click_point)
                    if dist < min_edge_dist:
                        min_edge_dist = dist
                        nearest_edge = edge_idx
            if nearest_edge is not None and min_edge_dist < 30:
                self.selected_edges.remove(nearest_edge)
                if nearest_edge in self.arterial_edges:
                    self.arterial_edges.remove(nearest_edge)
                print(f"已取消选择道路: {nearest_edge}")
                self.draw_map()
                return

        # 只要距离最近节点不大于阈值，就走选节点逻辑
        if nearest_node is not None and min_node_dist < 100:
            self.temp_edge.append(nearest_node)
            print(f"选择节点: {nearest_node}")
            if len(self.temp_edge) == 2:
                start_node, end_node = self.temp_edge
                path = self.find_shortest_path(start_node, end_node)
                if path:
                    # 只选中起点和终点
                    self.selected_nodes.add(start_node)
                    self.selected_nodes.add(end_node)
                    for i in range(len(path) - 1):
                        u, v = path[i], path[i + 1]
                        if self.original_G.has_edge(u, v):
                            for k in self.original_G.get_edge_data(u, v).keys():
                                self.selected_edges.add((u, v, k))
                                print(f"添加边: ({u}, {v}, {k})")
                    print(f"已添加从 {start_node} 到 {end_node} 的最短路径对应的边，只选中两端节点")
                self.temp_edge = []
            self.draw_map()

    def select_arterial(self, event):
        x, y = event.xdata, event.ydata
        click_point = Point(x, y)
        min_dist = float('inf')
        nearest_node = None
        for node_id, node_data in self.nodes.iterrows():
            node_geom = node_data.geometry
            dist = node_geom.distance(click_point)
            if dist < min_dist:
                min_dist = dist
                nearest_node = node_id
        if nearest_node is not None and min_dist < 100:
            self.temp_edge.append(nearest_node)
            if len(self.temp_edge) == 2:
                start_node, end_node = self.temp_edge
                path = self.find_shortest_path(start_node, end_node)
                if path:
                    self.selected_nodes.add(start_node)
                    self.selected_nodes.add(end_node)
                    for i in range(len(path) - 1):
                        u, v = path[i], path[i + 1]
                        if self.original_G.has_edge(u, v):
                            for k in self.original_G.get_edge_data(u, v).keys():
                                self.selected_edges.add((u, v, k))
                                self.arterial_edges.add((u, v, k))  # 关键：标记为主干道
                self.temp_edge = []
            self.draw_map()

    def find_shortest_path(self, start_node, end_node):
        try:
            path = nx.shortest_path(self.original_G, start_node, end_node, weight='length')
            return path
        except nx.NetworkXNoPath:
            print(f"节点 {start_node} 与 {end_node} 之间没有找到路径")
            return None

    def finalize_selection(self, event):
        if len(self.selected_nodes) == 0:
            print("没有选择任何节点")
            return
        if len(self.selected_edges) == 0:
            print("没有选择任何有效边")
            return

        self.selected_G = nx.MultiDiGraph()
        for key, value in self.original_G.graph.items():
            self.selected_G.graph[key] = value
        for node_id in self.selected_nodes:
            if node_id in self.original_G.nodes:
                node_data = self.original_G.nodes[node_id]
                # New: Add attribute for gathering point
                if node_id in self.gathering_points:
                    node_data['gathering_point'] = True
                self.selected_G.add_node(node_id, **node_data)
        for u, v, k in self.selected_edges:
            if self.original_G.has_edge(u, v, key=k):
                for node in [u, v]:
                    if node not in self.selected_G.nodes and node in self.original_G.nodes:
                        node_data = self.original_G.nodes[node]
                        # New: Add attribute for gathering point
                        if node in self.gathering_points:
                            node_data['gathering_point'] = True
                        self.selected_G.add_node(node, **node_data)
                edge_data = self.original_G.get_edge_data(u, v, key=k)
                edge_data['arterial'] = (u, v, k) in self.arterial_edges
                self.selected_G.add_edge(u, v, key=k, **edge_data)
        self.display_selected_network()

    def display_selected_network(self):
        try:
            fig, ax = plt.subplots(figsize=(10, 8))
            nodes, edges = ox.graph_to_gdfs(self.selected_G)
            # --------- 区域上色及形心标记 ----------
            arterial_lines = []
            for (u, v, k) in self.arterial_edges:
                if (u, v, k) in edges.index:
                    edge_geom = edges.loc[(u, v, k)].geometry
                    if edge_geom.geom_type == 'MultiLineString':
                        for line in edge_geom.geoms:
                            arterial_lines.append(line)
                    elif edge_geom.geom_type == 'LineString':
                        arterial_lines.append(edge_geom)
            region_centroids = []  # 存储形心
            if arterial_lines:
                merged = linemerge(arterial_lines)
                merged = snap(merged, merged, tolerance=1e-6)
                if hasattr(merged, '__iter__'):
                    lines_for_poly = list(merged)
                else:
                    lines_for_poly = [merged]
                polygons = list(polygonize(lines_for_poly))
                fill_polys = []
                for poly in polygons:
                    if poly.area > 10:
                        fill_polys.append(poly)
                region_colors = itertools.cycle([
                    '#FFEDA0', '#A1D99B', '#9ECAE1', '#FEC44F', '#FB6A4A', '#BCBDDC', '#FEE0D2', '#BDBDBD'
                ])
                for idx, poly in enumerate(fill_polys):
                    x, y = poly.exterior.xy
                    ax.fill(x, y, color=next(region_colors), alpha=0.4, label=f'Region {idx + 1}' if idx == 0 else "")
                    # 计算形心
                    centroid = poly.centroid
                    region_centroids.append(centroid)
                    # 用三角形标出形心
                    ax.scatter(centroid.x, centroid.y, marker='^', s=150, color="orange", edgecolor="black",
                               label="需求点" if idx == 0 else "")
            # --------- END 区域上色及形心 ----------
            if len(edges) > 0:
                edge_colors = []
                edge_widths = []
                for _, edge_data in edges.iterrows():
                    if edge_data.get('arterial', False):
                        edge_colors.append('black')
                        edge_widths.append(4)
                    else:
                        edge_colors.append('blue')
                        edge_widths.append(2)
                edges.plot(ax=ax, color=edge_colors, linewidth=edge_widths)

                # Node coloring
                node_colors = []
                node_sizes = []
                for node_id, node_data in nodes.iterrows():
                    if node_id in self.gathering_points:  # New: Mark gathering points as green
                        node_colors.append('green')
                        node_sizes.append(150)
                    elif node_id in self.selected_nodes:
                        node_colors.append('red')
                        node_sizes.append(100)
                    else:
                        node_colors.append('lightgrey')
                        node_sizes.append(50)

                # Plot nodes with appropriate colors
                nodes.plot(ax=ax, color=node_colors, markersize=node_sizes, alpha=0.8)

                selected_node_set = set([node for node in self.selected_nodes if node in self.selected_G.nodes()])
                processed_pairs = set()
                edge_lengths = {}
                for u, v, k, data in self.selected_G.edges(keys=True, data=True):
                    if (u, v) in processed_pairs or (v, u) in processed_pairs:
                        continue
                    if u in selected_node_set and v in selected_node_set:
                        length = data.get('length', 0)
                        edge_lengths[(u, v)] = length
                        processed_pairs.add((u, v))
                    elif u in selected_node_set or v in selected_node_set:
                        red_node = u if u in selected_node_set else v
                        other_node = v if red_node == u else u
                        visited = {red_node, other_node}
                        queue = [(other_node, red_node, data.get('length', 0))]
                        while queue:
                            current, start_red, current_length = queue.pop(0)
                            for neighbor in self.selected_G.neighbors(current):
                                if neighbor in visited:
                                    continue
                                edge_keys = list(self.selected_G.get_edge_data(current, neighbor).keys())
                                if edge_keys:
                                    edge_data2 = self.selected_G.get_edge_data(current, neighbor, edge_keys[0])
                                    edge_length = edge_data2.get('length', 0)
                                    total_length = current_length + edge_length
                                    if neighbor in selected_node_set:
                                        if ((start_red, neighbor) not in processed_pairs and
                                                (neighbor, start_red) not in processed_pairs):
                                            edge_lengths[(start_red, neighbor)] = total_length
                                            processed_pairs.add((start_red, neighbor))
                                        break
                                    else:
                                        visited.add(neighbor)
                                        queue.append((neighbor, start_red, total_length))
                for (u, v), length in edge_lengths.items():
                    u_coords = (nodes.loc[u].geometry.x, nodes.loc[u].geometry.y)
                    v_coords = (nodes.loc[v].geometry.x, nodes.loc[v].geometry.y)
                    mid_x = (u_coords[0] + v_coords[0]) / 2
                    mid_y = (u_coords[1] + v_coords[1]) / 2
                    ax.text(mid_x, mid_y, f"{length:.1f}m",
                            fontsize=9, color='green', backgroundcolor='white',
                            ha='center', va='center', weight='bold')

            from matplotlib.lines import Line2D
            legend_elements = [
                Line2D([0], [0], color='blue', linewidth=2, label='Regular Road'),
                Line2D([0], [0], color='black', linewidth=4, label='Arterial Road'),
                Line2D([0], [0], marker='o', color='w', markerfacecolor='red', markersize=8, label='Selected Node'),
                Line2D([0], [0], marker='o', color='w', markerfacecolor='green', markersize=8,
                       label='Gathering Point P'),  # New: Add gathering point to legend
                Line2D([0], [0], color='#FFEDA0', lw=10, alpha=0.4, label='Region'),
                Line2D([0], [0], marker='^', color='w', markerfacecolor='orange', markeredgecolor='black',
                       markersize=12, label='Needs point')
            ]
            ax.legend(handles=legend_elements, loc='upper right')
            ax.set_title(f'Selected Road Network - {self.location_name}')
            plt.tight_layout()
            plt.show()
        except ValueError as e:
            print(f"获取节点和边时出现错误，可能是图为空: {e}")
            print(f"图中节点数: {len(self.selected_G.nodes)}")
            print(f"图中边数: {self.selected_G.number_of_edges()}")
        except Exception as e:
            print(f"显示所选网络时出错: {e}")
            import traceback
            traceback.print_exc()

    def reset_selection(self, event):
        self.selected_nodes = set()
        self.selected_edges = set()
        self.arterial_edges = set()
        self.gathering_points = set()  # New: Reset gathering points
        self.temp_edge = []
        self.draw_map()
        print("已重置所有选择")

if __name__ == "__main__":
    selector = RoadNetworkSelector(
        location=(43.061936, 141.354292),
        dist=1500,
        location_name="Hokkaido Sapporo"
    )
