import osmnx as ox
import networkx as nx
import matplotlib.pyplot as plt
from matplotlib.widgets import Button
import numpy as np
from shapely.geometry import Point

class RoadNetworkSelector:
    def __init__(self, location=None, dist=1000, location_name=""):
        # Store location name
        self.location_name = location_name if location_name else "Selected Area"

        # Get map data using coordinates (more reliable than place names)
        if location:
            self.G = ox.graph_from_point(location, dist=dist, network_type='drive')
        else:
            # Default to Shanghai center coordinates
            self.G = ox.graph_from_point((31.2304, 121.4737), dist=2000, network_type='drive')
            if not location_name:
                self.location_name = "Shanghai"

        # Project the graph
        self.G = ox.project_graph(self.G)

        # Get nodes and edges
        self.nodes, self.edges = ox.graph_to_gdfs(self.G)

        # Save original graph
        self.original_G = self.G.copy()

        # Create an empty graph to store selected nodes and edges - use MultiDiGraph instead of DiGraph
        self.selected_G = nx.MultiDiGraph()

        # Add graph attributes from original graph
        for key, value in self.original_G.graph.items():
            self.selected_G.graph[key] = value

        # Store selected node and edge IDs
        self.selected_nodes = set()
        self.selected_edges = set()

        # Interaction state
        self.mode = 'nodes'  # 'nodes' or 'edges'
        self.selecting = False
        self.temp_edge = []  # Temporarily store nodes for edge selection

        # Create plot window
        self.fig, self.ax = plt.subplots(figsize=(12, 10))
        plt.subplots_adjust(bottom=0.2, top=0.9)  # Make space for buttons and title

        # Add buttons
        self.add_buttons()

        # Initial map draw
        self.draw_map()
        self.connect_events()

        plt.tight_layout()
        plt.show()

    def add_buttons(self):
        # Add toggle mode button
        ax_toggle = plt.axes([0.15, 0.05, 0.2, 0.075])
        self.btn_toggle = Button(ax_toggle, 'Switch to Road Selection')
        self.btn_toggle.on_clicked(self.toggle_mode)

        # Add done button
        ax_done = plt.axes([0.4, 0.05, 0.2, 0.075])
        self.btn_done = Button(ax_done, 'Complete Selection')
        self.btn_done.on_clicked(self.finalize_selection)

        # Add reset button
        ax_reset = plt.axes([0.65, 0.05, 0.2, 0.075])
        self.btn_reset = Button(ax_reset, 'Reset')
        self.btn_reset.on_clicked(self.reset_selection)

    def draw_map(self):
        self.ax.clear()

        # Draw original map edges
        edges = self.edges.copy()
        edge_colors = ['grey'] * len(edges)
        edge_widths = [1] * len(edges)

        # Highlight selected edges
        for i, (u, v, k) in enumerate(edges.index):
            if (u, v, k) in self.selected_edges:
                edge_colors[i] = 'blue'
                edge_widths[i] = 3

        # Draw edges
        edges.plot(ax=self.ax, color=edge_colors, linewidth=edge_widths, alpha=0.7)

        # Draw original nodes
        node_colors = ['lightgrey'] * len(self.nodes)
        node_sizes = [30] * len(self.nodes)

        # Highlight selected nodes
        for i, node_id in enumerate(self.nodes.index):
            if node_id in self.selected_nodes:
                node_colors[i] = 'red'
                node_sizes[i] = 100

        # Draw nodes
        self.nodes.plot(ax=self.ax, color=node_colors, markersize=node_sizes, alpha=0.8)

        # Set location name as the main title
        plt.suptitle(self.location_name, fontsize=16, y=0.98)

        if self.mode == 'nodes':
            subtitle = 'Selection Mode: Nodes - Click on intersections'
            self.btn_toggle.label.set_text('Switch to Road Selection')
        else:
            subtitle = 'Selection Mode: Roads - Click two nodes to select shortest path between them'
            self.btn_toggle.label.set_text('Switch to Node Selection')

        plt.title(subtitle, fontsize=12)

        self.ax.set_xlabel('Longitude')
        self.ax.set_ylabel('Latitude')
        self.fig.canvas.draw_idle()

    def connect_events(self):
        self.cid_click = self.fig.canvas.mpl_connect('button_press_event', self.on_click)

    def toggle_mode(self, event):
        if self.mode == 'nodes':
            self.mode = 'edges'
            self.btn_toggle.label.set_text('Switch to Node Selection')
        else:
            self.mode = 'nodes'
            self.btn_toggle.label.set_text('Switch to Road Selection')
        self.temp_edge = []  # Reset temporary edge
        self.draw_map()

    def on_click(self, event):
        if event.inaxes != self.ax:
            return

        if self.mode == 'nodes':
            self.select_node(event)
        else:
            self.select_edge(event)

    def select_node(self, event):
        # Get click position
        x, y = event.xdata, event.ydata
        click_point = Point(x, y)

        # Find nearest node
        min_dist = float('inf')
        nearest_node = None

        for node_id, node_data in self.nodes.iterrows():
            node_geom = node_data.geometry
            dist = node_geom.distance(click_point)
            if dist < min_dist:
                min_dist = dist
                nearest_node = node_id

        # If node found and close enough (30 units is an empirical value, adjust as needed)
        if nearest_node is not None and min_dist < 100:
            if nearest_node in self.selected_nodes:
                # Remove the node (do NOT remove any edges)
                self.selected_nodes.remove(nearest_node)
                print(f"取消选择节点: {nearest_node}，但保留相关边")
            else:
                self.selected_nodes.add(nearest_node)
                print(f"选择节点: {nearest_node}")

            # Redraw the map
            self.draw_map()

    def select_edge(self, event):
        # Get click position
        x, y = event.xdata, event.ydata
        click_point = Point(x, y)

        # Find nearest node
        min_dist = float('inf')
        nearest_node = None

        for node_id, node_data in self.nodes.iterrows():
            node_geom = node_data.geometry
            dist = node_geom.distance(click_point)
            if dist < min_dist:
                min_dist = dist
                nearest_node = node_id

        # If node found and close enough
        if nearest_node is not None and min_dist < 100:
            self.temp_edge.append(nearest_node)
            print(f"选择节点: {nearest_node}")

            # If two nodes selected, find and add shortest path between them
            if len(self.temp_edge) == 2:
                start_node, end_node = self.temp_edge

                # Find shortest path
                path = self.find_shortest_path(start_node, end_node)

                if path:
                    # Add all nodes in the path
                    for node in path:
                        self.selected_nodes.add(node)

                    # Add all edges along the path
                    for i in range(len(path) - 1):
                        u, v = path[i], path[i + 1]
                        if self.original_G.has_edge(u, v):
                            # There might be multiple edges between the same nodes
                            # Get all edges between u and v
                            for k in self.original_G.get_edge_data(u, v).keys():
                                self.selected_edges.add((u, v, k))
                                print(f"添加边: ({u}, {v}, {k})")

                    print(f"已添加从 {start_node} 到 {end_node} 的最短路径，共包含 {len(path)} 个节点")

                # Reset temporary edge
                self.temp_edge = []

            # Redraw the map
            self.draw_map()

    def find_shortest_path(self, start_node, end_node):
        """Find the shortest path between two nodes based on number of nodes traversed"""
        try:
            # Try to find path in original graph
            path = nx.shortest_path(self.original_G, start_node, end_node, weight='length')
            return path
        except nx.NetworkXNoPath:
            print(f"节点 {start_node} 与 {end_node} 之间没有找到路径")
            return None

    def finalize_selection(self, event):
        # Check if there are any nodes or edges selected
        if len(self.selected_nodes) == 0:
            print("没有选择任何节点")
            return

        if len(self.selected_edges) == 0:
            print("没有选择任何有效边")
            return

        # Create selected subgraph - use MultiDiGraph instead of DiGraph
        self.selected_G = nx.MultiDiGraph()

        # Copy graph attributes from original graph
        for key, value in self.original_G.graph.items():
            self.selected_G.graph[key] = value

        # Add selected nodes (only those in self.selected_nodes)
        for node_id in self.selected_nodes:
            if node_id in self.original_G.nodes:
                node_data = self.original_G.nodes[node_id]
                self.selected_G.add_node(node_id, **node_data)

        # Add selected edges (even if they connect到未选中的节点)
        for u, v, k in self.selected_edges:
            if self.original_G.has_edge(u, v, key=k):
                # 保证边的两个端点都在selected_G里
                for node in [u, v]:
                    if node not in self.selected_G.nodes and node in self.original_G.nodes:
                        node_data = self.original_G.nodes[node]
                        self.selected_G.add_node(node, **node_data)
                edge_data = self.original_G.get_edge_data(u, v, key=k)
                self.selected_G.add_edge(u, v, key=k, **edge_data)

        # Create new window to display selected network
        self.display_selected_network()

    def display_selected_network(self):
        try:
            # Create new window
            fig, ax = plt.subplots(figsize=(10, 8))

            # 获取所有边
            nodes, edges = ox.graph_to_gdfs(self.selected_G)

            if len(edges) > 0:
                # 只画边
                edges.plot(ax=ax, color='blue', linewidth=2)

                # 在每条边旁边显示权值
                for _, edge in edges.iterrows():
                    # 获取边的起点和终点坐标
                    if 'geometry' in edge and edge['geometry']:
                        # 计算边的中点
                        line_geometry = edge['geometry']
                        midpoint = line_geometry.interpolate(0.5, normalized=True)

                        if midpoint:
                            # 获取边的长度（权值）
                            length = edge.get('length', None)
                            if length is not None:
                                # 在地图上标注长度，单位为米
                                ax.text(midpoint.x, midpoint.y, f"{length:.1f}m", fontsize=8, color='green')

            # 只画self.selected_nodes中的节点
            if len(self.selected_nodes) > 0:
                # 获取self.selected_nodes对应的gdf（用原nodes表过滤）
                plot_nodes = self.nodes.loc[list(self.selected_nodes)]
                plot_nodes.plot(ax=ax, color='red', markersize=50)

            ax.set_title(f'Selected Road Network - {self.location_name}')
            plt.tight_layout()
            plt.show()
        except ValueError as e:
            print(f"获取节点和边时出现错误，可能是图为空: {e}")
            print(f"图中节点数: {len(self.selected_G.nodes)}")
            print(f"图中边数: {self.selected_G.number_of_edges()}")
        except Exception as e:
            print(f"显示所选网络时出错: {e}")
            import traceback
            traceback.print_exc()

    def reset_selection(self, event):
        self.selected_nodes = set()
        self.selected_edges = set()
        self.temp_edge = []
        self.draw_map()
        print("已重置所有选择")

if __name__ == "__main__":
    # Nishinomiya, Hyogo, Japan
    selector = RoadNetworkSelector(
        location=(34.7378, 135.3423),
        dist=1000,
        location_name="Nishinomiya, Hyogo"
    )
