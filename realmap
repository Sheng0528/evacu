import osmnx as ox
import networkx as nx
import matplotlib.pyplot as plt
from matplotlib.widgets import Button
import numpy as np
from shapely.geometry import Point, LineString, Polygon, MultiPolygon
from shapely.ops import polygonize, unary_union, linemerge, snap
from collections import defaultdict
import itertools

class RoadNetworkSelector:
    def __init__(self, location=None, dist=1000, location_name=""):
        self.location_name = location_name if location_name else "Selected Area"

        if location:
            self.G = ox.graph_from_point(location, dist=dist, network_type='drive')
        else:
            self.G = ox.graph_from_point((31.2304, 121.4737), dist=2000, network_type='drive')
            if not location_name:
                self.location_name = "Shanghai"

        self.G = ox.project_graph(self.G)
        self.nodes, self.edges = ox.graph_to_gdfs(self.G)
        self.original_G = self.G.copy()

        self.selected_G = nx.MultiDiGraph()
        for key, value in self.original_G.graph.items():
            self.selected_G.graph[key] = value

        self.selected_nodes = set()
        self.selected_edges = set()
        self.arterial_edges = set()

        self.mode = 'nodes'
        self.selecting = False
        self.temp_edge = []

        self.fig, self.ax = plt.subplots(figsize=(12, 10))
        plt.subplots_adjust(bottom=0.2, top=0.9)
        self.add_buttons()
        self.draw_map()
        self.connect_events()
        plt.tight_layout()
        plt.show()

    def add_buttons(self):
        ax_toggle = plt.axes([0.15, 0.05, 0.2, 0.075])
        self.btn_toggle = Button(ax_toggle, 'Switch to Road Selection')
        self.btn_toggle.on_clicked(self.toggle_mode)

        ax_arterial = plt.axes([0.15, 0.13, 0.2, 0.075])
        self.btn_arterial = Button(ax_arterial, 'Switch to Arterial Selection')
        self.btn_arterial.on_clicked(self.toggle_arterial)

        ax_done = plt.axes([0.4, 0.05, 0.2, 0.075])
        self.btn_done = Button(ax_done, 'Complete Selection')
        self.btn_done.on_clicked(self.finalize_selection)

        ax_reset = plt.axes([0.65, 0.05, 0.2, 0.075])
        self.btn_reset = Button(ax_reset, 'Reset')
        self.btn_reset.on_clicked(self.reset_selection)

    def draw_map(self):
        self.ax.clear()
        edges = self.edges.copy()
        edge_colors = ['grey'] * len(edges)
        edge_widths = [1] * len(edges)

        for i, (u, v, k) in enumerate(edges.index):
            if (u, v, k) in self.selected_edges:
                if (u, v, k) in self.arterial_edges:
                    edge_colors[i] = 'black'
                    edge_widths[i] = 4
                else:
                    edge_colors[i] = 'blue'
                    edge_widths[i] = 3

        edges.plot(ax=self.ax, color=edge_colors, linewidth=edge_widths, alpha=0.7)

        node_colors = ['lightgrey'] * len(self.nodes)
        node_sizes = [30] * len(self.nodes)

        for i, node_id in enumerate(self.nodes.index):
            if node_id in self.selected_nodes:
                node_colors[i] = 'red'
                node_sizes[i] = 100

        self.nodes.plot(ax=self.ax, color=node_colors, markersize=node_sizes, alpha=0.8)
        plt.suptitle(self.location_name, fontsize=16, y=0.98)

        if self.mode == 'nodes':
            subtitle = 'Selection Mode: Nodes - Click on intersections'
            self.btn_toggle.label.set_text('Switch to Road Selection')
            self.btn_arterial.label.set_text('Switch to Arterial Selection')
        elif self.mode == 'edges':
            subtitle = 'Selection Mode: Roads - Click two nodes to select shortest path between them'
            self.btn_toggle.label.set_text('Switch to Node Selection')
            self.btn_arterial.label.set_text('Switch to Arterial Selection')
        else:
            subtitle = 'Selection Mode: Arterial Roads - Click on roads to mark/unmark as arterial'
            self.btn_toggle.label.set_text('Switch to Node Selection')
            self.btn_arterial.label.set_text('Switch to Road Selection')

        plt.title(subtitle, fontsize=12)
        self.ax.set_xlabel('Longitude')
        self.ax.set_ylabel('Latitude')
        self.fig.canvas.draw_idle()

    def connect_events(self):
        self.cid_click = self.fig.canvas.mpl_connect('button_press_event', self.on_click)

    def toggle_mode(self, event):
        if self.mode == 'nodes':
            self.mode = 'edges'
            self.btn_toggle.label.set_text('Switch to Node Selection')
        else:
            self.mode = 'nodes'
            self.btn_toggle.label.set_text('Switch to Road Selection')
        self.temp_edge = []
        self.draw_map()

    def toggle_arterial(self, event):
        if self.mode == 'arterial':
            self.mode = 'edges'
            self.btn_arterial.label.set_text('Switch to Arterial Selection')
        else:
            self.mode = 'arterial'
            self.btn_arterial.label.set_text('Switch to Road Selection')
        self.temp_edge = []
        self.draw_map()

    def on_click(self, event):
        if event.inaxes != self.ax:
            return
        if self.mode == 'nodes':
            self.select_node(event)
        elif self.mode == 'edges':
            self.select_edge(event)
        else:
            self.select_arterial(event)

    def select_node(self, event):
        x, y = event.xdata, event.ydata
        click_point = Point(x, y)
        min_dist = float('inf')
        nearest_node = None
        for node_id, node_data in self.nodes.iterrows():
            node_geom = node_data.geometry
            dist = node_geom.distance(click_point)
            if dist < min_dist:
                min_dist = dist
                nearest_node = node_id
        if nearest_node is not None and min_dist < 100:
            if nearest_node in self.selected_nodes:
                self.selected_nodes.remove(nearest_node)
                print(f"取消选择节点: {nearest_node}，但保留相关边")
            else:
                self.selected_nodes.add(nearest_node)
                print(f"选择节点: {nearest_node}")
            self.draw_map()

    def select_edge(self, event):
        x, y = event.xdata, event.ydata
        click_point = Point(x, y)
        # 检查是否点中了已选边
        min_dist = float('inf')
        nearest_edge = None
        for edge_idx in self.selected_edges:
            if edge_idx in self.edges.index:
                edge_geom = self.edges.loc[edge_idx].geometry
                dist = edge_geom.distance(click_point)
                if dist < min_dist:
                    min_dist = dist
                    nearest_edge = edge_idx
        # 如果足够接近某条已选边，直接删除
        if nearest_edge is not None and min_dist < 30:
            self.selected_edges.remove(nearest_edge)
            # 还原主干道标记
            if nearest_edge in self.arterial_edges:
                self.arterial_edges.remove(nearest_edge)
            # 检查节点是否还属于其他选中边，否则可一并移除
            u, v, k = nearest_edge
            node_still_used = False
            for e in self.selected_edges:
                if u in e[:2] or v in e[:2]:
                    node_still_used = True
                    break
            if not node_still_used:
                for node in [u, v]:
                    if node in self.selected_nodes:
                        self.selected_nodes.remove(node)
            print(f"已取消选择道路: {nearest_edge}")
            self.draw_map()
            return
        # 否则，进入原有“两点选路”逻辑
        min_dist = float('inf')
        nearest_node = None
        for node_id, node_data in self.nodes.iterrows():
            node_geom = node_data.geometry
            dist = node_geom.distance(click_point)
            if dist < min_dist:
                min_dist = dist
                nearest_node = node_id
        if nearest_node is not None and min_dist < 100:
            self.temp_edge.append(nearest_node)
            print(f"选择节点: {nearest_node}")
            if len(self.temp_edge) == 2:
                start_node, end_node = self.temp_edge
                path = self.find_shortest_path(start_node, end_node)
                if path:
                    for node in path:
                        self.selected_nodes.add(node)
                    for i in range(len(path) - 1):
                        u, v = path[i], path[i + 1]
                        if self.original_G.has_edge(u, v):
                            for k in self.original_G.get_edge_data(u, v).keys():
                                self.selected_edges.add((u, v, k))
                                print(f"添加边: ({u}, {v}, {k})")
                    print(f"已添加从 {start_node} 到 {end_node} 的最短路径，共包含 {len(path)} 个节点")
                self.temp_edge = []
            self.draw_map()

    def select_arterial(self, event):
        x, y = event.xdata, event.ydata
        click_point = Point(x, y)
        min_dist = float('inf')
        nearest_edge = None
        for edge_idx, edge_data in self.edges.iterrows():
            edge_geom = edge_data.geometry
            dist = edge_geom.distance(click_point)
            if dist < min_dist:
                min_dist = dist
                nearest_edge = edge_idx
        if nearest_edge is not None and min_dist < 30:
            u, v, k = nearest_edge
            if (u, v, k) in self.selected_edges:
                if (u, v, k) in self.arterial_edges:
                    self.arterial_edges.remove((u, v, k))
                    print(f"取消主干道标记: ({u}, {v}, {k})")
                else:
                    self.arterial_edges.add((u, v, k))
                    print(f"标记为主干道: ({u}, {v}, {k})")
            else:
                self.selected_edges.add((u, v, k))
                self.arterial_edges.add((u, v, k))
                self.selected_nodes.add(u)
                self.selected_nodes.add(v)
                print(f"添加并标记为主干道: ({u}, {v}, {k})")
            self.draw_map()

    def find_shortest_path(self, start_node, end_node):
        try:
            path = nx.shortest_path(self.original_G, start_node, end_node, weight='length')
            return path
        except nx.NetworkXNoPath:
            print(f"节点 {start_node} 与 {end_node} 之间没有找到路径")
            return None

    def finalize_selection(self, event):
        if len(self.selected_nodes) == 0:
            print("没有选择任何节点")
            return
        if len(self.selected_edges) == 0:
            print("没有选择任何有效边")
            return

        self.selected_G = nx.MultiDiGraph()
        for key, value in self.original_G.graph.items():
            self.selected_G.graph[key] = value
        for node_id in self.selected_nodes:
            if node_id in self.original_G.nodes:
                node_data = self.original_G.nodes[node_id]
                self.selected_G.add_node(node_id, **node_data)
        for u, v, k in self.selected_edges:
            if self.original_G.has_edge(u, v, key=k):
                for node in [u, v]:
                    if node not in self.selected_G.nodes and node in self.original_G.nodes:
                        node_data = self.original_G.nodes[node]
                        self.selected_G.add_node(node, **node_data)
                edge_data = self.original_G.get_edge_data(u, v, key=k)
                edge_data['arterial'] = (u, v, k) in self.arterial_edges
                self.selected_G.add_edge(u, v, key=k, **edge_data)
        self.display_selected_network()

    def display_selected_network(self):
        try:
            fig, ax = plt.subplots(figsize=(10, 8))
            nodes, edges = ox.graph_to_gdfs(self.selected_G)

            # --------- 区域上色及形心标记 ----------
            arterial_lines = []
            for (u, v, k) in self.arterial_edges:
                if (u, v, k) in edges.index:
                    edge_geom = edges.loc[(u, v, k)].geometry
                    if edge_geom.geom_type == 'MultiLineString':
                        for line in edge_geom.geoms:
                            arterial_lines.append(line)
                    elif edge_geom.geom_type == 'LineString':
                        arterial_lines.append(edge_geom)
            region_centroids = []  # 存储形心
            if arterial_lines:
                merged = linemerge(arterial_lines)
                merged = snap(merged, merged, tolerance=1e-6)
                if hasattr(merged, '__iter__'):
                    lines_for_poly = list(merged)
                else:
                    lines_for_poly = [merged]
                polygons = list(polygonize(lines_for_poly))
                fill_polys = []
                for poly in polygons:
                    if poly.area > 10:
                        fill_polys.append(poly)
                region_colors = itertools.cycle([
                    '#FFEDA0', '#A1D99B', '#9ECAE1', '#FEC44F', '#FB6A4A', '#BCBDDC', '#FEE0D2', '#BDBDBD'
                ])
                for idx, poly in enumerate(fill_polys):
                    x, y = poly.exterior.xy
                    ax.fill(x, y, color=next(region_colors), alpha=0.4, label=f'Region {idx+1}' if idx==0 else "")
                    # 计算形心
                    centroid = poly.centroid
                    region_centroids.append(centroid)
                    # 用三角形标出形心
                    ax.scatter(centroid.x, centroid.y, marker='^', s=150, color="orange", edgecolor="black", label="需求点" if idx==0 else "")
            # --------- END 区域上色及形心 ----------

            if len(edges) > 0:
                edge_colors = []
                edge_widths = []
                for _, edge_data in edges.iterrows():
                    if edge_data.get('arterial', False):
                        edge_colors.append('black')
                        edge_widths.append(4)
                    else:
                        edge_colors.append('blue')
                        edge_widths.append(2)
                edges.plot(ax=ax, color=edge_colors, linewidth=edge_widths)
                selected_node_set = set([node for node in self.selected_nodes if node in self.selected_G.nodes()])
                processed_pairs = set()
                edge_lengths = {}
                for u, v, k, data in self.selected_G.edges(keys=True, data=True):
                    if (u, v) in processed_pairs or (v, u) in processed_pairs:
                        continue
                    if u in selected_node_set and v in selected_node_set:
                        length = data.get('length', 0)
                        edge_lengths[(u, v)] = length
                        processed_pairs.add((u, v))
                    elif u in selected_node_set or v in selected_node_set:
                        red_node = u if u in selected_node_set else v
                        other_node = v if red_node == u else u
                        visited = {red_node, other_node}
                        queue = [(other_node, red_node, data.get('length', 0))]
                        while queue:
                            current, start_red, current_length = queue.pop(0)
                            for neighbor in self.selected_G.neighbors(current):
                                if neighbor in visited:
                                    continue
                                edge_keys = list(self.selected_G.get_edge_data(current, neighbor).keys())
                                if edge_keys:
                                    edge_data2 = self.selected_G.get_edge_data(current, neighbor, edge_keys[0])
                                    edge_length = edge_data2.get('length', 0)
                                    total_length = current_length + edge_length
                                    if neighbor in selected_node_set:
                                        if ((start_red, neighbor) not in processed_pairs and
                                                (neighbor, start_red) not in processed_pairs):
                                            edge_lengths[(start_red, neighbor)] = total_length
                                            processed_pairs.add((start_red, neighbor))
                                        break
                                    else:
                                        visited.add(neighbor)
                                        queue.append((neighbor, start_red, total_length))
                for (u, v), length in edge_lengths.items():
                    u_coords = (nodes.loc[u].geometry.x, nodes.loc[u].geometry.y)
                    v_coords = (nodes.loc[v].geometry.x, nodes.loc[v].geometry.y)
                    mid_x = (u_coords[0] + v_coords[0]) / 2
                    mid_y = (u_coords[1] + v_coords[1]) / 2
                    ax.text(mid_x, mid_y, f"{length:.1f}m",
                            fontsize=9, color='green', backgroundcolor='white',
                            ha='center', va='center', weight='bold')
            if len(self.selected_nodes) > 0:
                selected_node_ids = [node_id for node_id in self.selected_nodes if node_id in nodes.index]
                if selected_node_ids:
                    plot_nodes = nodes.loc[selected_node_ids]
                    plot_nodes.plot(ax=ax, color='red', markersize=50)
            from matplotlib.lines import Line2D
            legend_elements = [
                Line2D([0], [0], color='blue', linewidth=2, label='Regular Road'),
                Line2D([0], [0], color='black', linewidth=4, label='Arterial Road'),
                Line2D([0], [0], marker='o', color='w', markerfacecolor='red', markersize=8, label='Selected Node'),
                Line2D([0], [0], color='#FFEDA0', lw=10, alpha=0.4, label='Region'),
                Line2D([0], [0], marker='^', color='w', markerfacecolor='orange', markeredgecolor='black', markersize=12, label='Needs point')
            ]
            ax.legend(handles=legend_elements, loc='upper right')
            ax.set_title(f'Selected Road Network - {self.location_name}')
            plt.tight_layout()
            plt.show()
        except ValueError as e:
            print(f"获取节点和边时出现错误，可能是图为空: {e}")
            print(f"图中节点数: {len(self.selected_G.nodes)}")
            print(f"图中边数: {self.selected_G.number_of_edges()}")
        except Exception as e:
            print(f"显示所选网络时出错: {e}")
            import traceback
            traceback.print_exc()

    def reset_selection(self, event):
        self.selected_nodes = set()
        self.selected_edges = set()
        self.arterial_edges = set()
        self.temp_edge = []
        self.draw_map()
        print("已重置所有选择")

if __name__ == "__main__":
    selector = RoadNetworkSelector(
        location=(35.010221, 135.768158),  # 东京台场中心坐标
        dist=2000,
        location_name="Kyoto Nakagyo"
    )
